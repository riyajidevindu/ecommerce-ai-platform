name: CD

on:
  push:
    branches: [ main ]
  workflow_dispatch: {}

env:
  AWS_REGION: ap-south-1
  NAMESPACE: ecommerce

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate AWS_ROLE_ARN format
        shell: bash
        env:
          AWS_ROLE_ARN: ${{ secrets.AWS_ROLE_ARN }}
        run: |
          if [[ ! "$AWS_ROLE_ARN" =~ ^arn:aws:iam::[0-9]{12}:role/.+ ]]; then
            echo "ERROR: AWS_ROLE_ARN does not look like a valid IAM role ARN (expected: arn:aws:iam::123456789012:role/YourRole).";
            echo "Tip: Do NOT use an STS assumed-role ARN (arn:aws:sts::...:assumed-role/...). Copy the ARN from the IAM Role page.";
            exit 1;
          fi
          echo "AWS_ROLE_ARN format looks OK."

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: gha-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Who am I? (build phase)
        run: aws sts get-caller-identity

      - name: Login to ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push images
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          GIT_SHA: ${{ github.sha }}
        run: |
          set -e
          # Build and push per service
          declare -a services=(
            "auth-service"
            "stock-service"
            "whatsapp-connector-service"
            "ai-orchestrator-service"
            "notification-service"
            "file-storage-service"
          )
          for svc in "${services[@]}"; do
            docker build -t "$ECR_REGISTRY/$svc:latest" -t "$ECR_REGISTRY/$svc:$GIT_SHA" "services/$svc"
            docker push "$ECR_REGISTRY/$svc:latest"
            docker push "$ECR_REGISTRY/$svc:$GIT_SHA"
          done

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout manifests
        uses: actions/checkout@v4

      - name: Install kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: v1.30.0

      - name: Install Helm
        uses: azure/setup-helm@v4
        with:
          version: v3.14.4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: gha-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Who am I? (deploy phase)
        run: aws sts get-caller-identity

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --region $AWS_REGION --name ${{ secrets.EKS_CLUSTER_NAME }}

      - name: Install/upgrade cert-manager (CRDs + controller)
        run: |
          set -e
          CM_VER=v1.15.3
          kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/${CM_VER}/cert-manager.crds.yaml
          helm repo add jetstack https://charts.jetstack.io
          helm repo update
          helm upgrade --install cert-manager jetstack/cert-manager \
            --namespace cert-manager \
            --create-namespace \
            --version ${CM_VER}
          kubectl -n cert-manager rollout status deploy/cert-manager --timeout=5m
          kubectl -n cert-manager rollout status deploy/cert-manager-webhook --timeout=5m
          kubectl -n cert-manager rollout status deploy/cert-manager-cainjector --timeout=5m

      - name: Install/upgrade Traefik Ingress Controller
        run: |
          set -e
          helm repo add traefik https://traefik.github.io/charts
          helm repo update
          helm upgrade --install traefik traefik/traefik \
            --namespace traefik \
            --create-namespace
          kubectl -n traefik rollout status deploy/traefik --timeout=5m

      - name: Login to ECR (for registry URL)
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Apply manifests
        env:
          RABBITMQ_URL: ${{ secrets.RABBITMQ_URL }}
          AUTH_DATABASE_URL: ${{ secrets.AUTH_DATABASE_URL }}
          AUTH_SECRET_KEY: ${{ secrets.AUTH_SECRET_KEY }}
          STOCK_DATABASE_URL: ${{ secrets.STOCK_DATABASE_URL }}
          WHATSAPP_DATABASE_URL: ${{ secrets.WHATSAPP_DATABASE_URL }}
          AI_DATABASE_URL: ${{ secrets.AI_DATABASE_URL }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
          CORS_ALLOW_ORIGINS: ${{ secrets.CORS_ALLOW_ORIGINS }}
          CORS_ALLOW_ORIGIN_REGEX: ${{ secrets.CORS_ALLOW_ORIGIN_REGEX }}
          WHATSAPP_ACCESS_TOKEN: ${{ secrets.WHATSAPP_ACCESS_TOKEN }}
          WHATSAPP_PHONE_NUMBER_ID: ${{ secrets.WHATSAPP_PHONE_NUMBER_ID }}
          WHATSAPP_API_VERSION: ${{ secrets.WHATSAPP_API_VERSION }}
          WHATSAPP_VERIFY_TOKEN: ${{ secrets.WHATSAPP_VERIFY_TOKEN }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          RDS_ENDPOINT: ${{ secrets.RDS_ENDPOINT }}
          RDS_MASTER_USERNAME: ${{ secrets.RDS_MASTER_USERNAME }}
          RDS_MASTER_PASSWORD: ${{ secrets.RDS_MASTER_PASSWORD }}
          APP_DB_PASSWORD: ${{ secrets.APP_DB_PASSWORD }}
        run: |
          set -e
          cat > k8s/overlays/prod/secrets.env << EOF
          rabbitmq_url=${RABBITMQ_URL}
          database_url=${AUTH_DATABASE_URL}
          secret_key=${AUTH_SECRET_KEY}
          stock_database_url=${STOCK_DATABASE_URL}
          whatsapp_database_url=${WHATSAPP_DATABASE_URL}
          ai_database_url=${AI_DATABASE_URL}
          gemini_api_key=${GEMINI_API_KEY}
          groq_api_key=${GROQ_API_KEY}
          CORS_ALLOW_ORIGINS=${CORS_ALLOW_ORIGINS}
          CORS_ALLOW_ORIGIN_REGEX=${CORS_ALLOW_ORIGIN_REGEX}
          whatsapp_access_token=${WHATSAPP_ACCESS_TOKEN}
          whatsapp_phone_number_id=${WHATSAPP_PHONE_NUMBER_ID}
          whatsapp_api_version=${WHATSAPP_API_VERSION}
          whatsapp_verify_token=${WHATSAPP_VERIFY_TOKEN}
          google_client_id=${GOOGLE_CLIENT_ID}
          google_client_secret=${GOOGLE_CLIENT_SECRET}
          RDS_ENDPOINT=${RDS_ENDPOINT}
          RDS_MASTER_USERNAME=${RDS_MASTER_USERNAME}
          RDS_MASTER_PASSWORD=${RDS_MASTER_PASSWORD}
          APP_DB_PASSWORD=${APP_DB_PASSWORD}
          EOF
          kubectl apply -k k8s/overlays/prod

      - name: Roll deployments to new image tag
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          set -e
          declare -a deployments=(
            "auth-service:auth"
            "stock-service:stock"
            "whatsapp-connector-service:whatsapp"
            "ai-orchestrator-service:ai"
            "notification-service:notification"
            "file-storage-service:file-storage"
          )
          for item in "${deployments[@]}"; do
            IFS=":" read -r deploy container <<< "$item"
            echo "Setting $deploy ($container) -> $ECR_REGISTRY/$deploy:$IMAGE_TAG"
            kubectl -n $NAMESPACE set image deployment/$deploy $container=$ECR_REGISTRY/$deploy:$IMAGE_TAG --record=true
          done

      - name: Wait for rollout
        env:
          TIMEOUT: 10m
        run: |
          set -e
          for d in auth-service stock-service whatsapp-connector-service ai-orchestrator-service notification-service file-storage-service; do
            echo "Waiting for rollout of $d"
            kubectl -n $NAMESPACE rollout status deployment/$d --timeout=$TIMEOUT
          done

      - name: Debug on failure (pods, events)
        if: failure()
        run: |
          echo "--- Pods ---"; kubectl -n $NAMESPACE get pods -o wide || true
          echo "--- Auth deployment describe ---"; kubectl -n $NAMESPACE describe deployment auth-service || true
          echo "--- Auth pods describe ---"; for p in $(kubectl -n $NAMESPACE get pods -l app=auth-service -o name); do kubectl -n $NAMESPACE describe $p || true; done
          echo "--- Auth pods logs (last 200) ---"; for p in $(kubectl -n $NAMESPACE get pods -l app=auth-service -o name); do kubectl -n $NAMESPACE logs --tail=200 $p || true; done
          echo "--- Recent events ---"; kubectl -n $NAMESPACE get events --sort-by=.metadata.creationTimestamp | tail -n 100 || true
